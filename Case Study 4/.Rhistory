pacman::p_load(survival, randomForestSRC, MASS, SMCRM, tidyverse, here, skimr, corrplot, rpart)
data(acquisitionRetention)
rawdf <- acquisitionRetention
str(rawdf)
head(rawdf)
rawdf %>% select_if(is.numeric) %>% cor() %>% corrplot(method = 'number', number.cex = 0.6)
# Survival Plot
surv <- data.frame(duration = seq(0,max(rawdf$duration), by = 1))
surv1 <- surv %>%
group_by(duration) %>%
mutate(dist = sum(rawdf$duration > duration))
#greater than removes all of the results where duration == 0, i.e. those not acquired
surv1 %>% ggplot(aes(x = duration, y = dist)) +
geom_line() +
scale_y_continuous(name = 'Count', sec.axis = sec_axis(trans = ~./max(surv1$dist), name = 'Distribution'))
surv2 <- surv1 %>%
ungroup() %>%
mutate(dens = dist - lead(dist, 1),
dens = ifelse(is.na(dens), 0, dens),
hazard = dens/dist,
dens2 = dens/max(dist)
)
surv2 %>% ggplot(aes(x = duration, y = dens2)) +
geom_line()
?acquisitionRetention
pacman::p_load(survival, randomForestSRC, MASS, SMCRM, tidyverse, here, skimr, corrplot, rpart)
data(acquisitionRetention)
rawdf <- acquisitionRetention
str(rawdf)
head(rawdf)
skim(rawdf)
rawdf <- rawdf %>% mutate_at(c('industry', 'acquisition'), as.factor)
#column definitions
?acquisitionRetention
rawdf %>% select_if(is.numeric) %>% cor() %>% corrplot(method = 'number', number.cex = 0.6)
# Survival Plot
surv <- data.frame(duration = seq(0,max(rawdf$duration), by = 1))
surv1 <- surv %>%
group_by(duration) %>%
mutate(dist = sum(rawdf$duration > duration))
#greater than removes all of the results where duration == 0, i.e. those not acquired
surv1 %>% ggplot(aes(x = duration, y = dist)) +
geom_line() +
scale_y_continuous(name = 'Count', sec.axis = sec_axis(transform = ~./max(surv1$dist), name = 'Distribution'))
sum(rawdf[which(rawdf$acquisition == 0),]$duration)
rawdf %>% select(ends_with('sq')) %>% names()
set.seed(321)
acq_part <- sample(nrow(rawdf),0.8*nrow(rawdf),replace = F)
acq_train1 <- rawdf[acq_part,]
acq_test1 <- rawdf[-acq_part,]
acq_train1 <- acq_train1 %>% select(-c(profit, duration, ret_exp, ret_exp_sq, freq, freq_sq, crossbuy, sow))
acq_test1 <- acq_test1 %>% select(-c(profit, duration, ret_exp, ret_exp_sq, freq, freq_sq, crossbuy, sow))
set.seed(321)
logfit1 <- step(glm(acquisition ~ . -customer,
data = acq_train1, family = binomial),
direction = "backward", trace = 0)
summary(logfit1)
car::vif(logfit1)
set.seed(321)
logfit2 <- step(glm(acquisition ~ . -acq_exp_sq -customer,
data = acq_train1, family = binomial),
direction = "backward", trace = 0)
summary(logfit2)
car::vif(logfit2)
plot(logfit2)
acq_preds <- data.frame(actual = acq_test1$acquisition,
log_preds = predict(logfit2, acq_test1, type = 'response')) %>% mutate(
log_preds = as.factor(ifelse(log_preds >= 0.5, 1, 0))
)
set.seed(321)
dtfit1 <- rpart(acquisition ~ . -customer, data = acq_train1)
summary(dtfit1)
rattle::fancyRpartPlot(dtfit1, sub = '')
acq_preds$dt_preds <- predict(dtfit1, acq_test1)
set.seed(321)
rffit1 <- rfsrc(acquisition ~ . -acq_exp_sq -customer,
data = acq_train1,
importance = TRUE,
ntree = 100)
rffit1
rffit1$importance
acq_mindepth <- max.subtree(rffit1, sub.order = T)
print(round(acq_mindepth$order, 3)[,1])
find.interaction(rffit1, method = 'vimp', importance = 'permute')
acq_test_prob <- predict(rffit1, newdata = acq_test1)$predicted[,2]
acq_preds$rf_preds <- acq_test_prob
acq_preds <- acq_preds %>% mutate(rf_preds = as.factor(ifelse(rf_preds >= 0.5, 1, 0)))
caret::confusionMatrix(acq_preds$log_preds, reference = acq_preds$actual, positive = '1')
caret::confusionMatrix(acq_preds$rf_preds, reference = acq_preds$actual, positive = '1')
acq_raw_prob <- predict(rffit1, newdata = select(rawdf, names(acq_test1)))$predicted[,2]
durdf <- rawdf %>% bind_cols(preds = acq_raw_prob) %>% mutate(
acq_preds = as.factor(ifelse(preds >= 0.5, 1, 0))
)
caret::confusionMatrix(durdf$acq_preds, durdf$acquisition, positive = '1')
durdf1 <- durdf %>% filter(acq_preds == 1) %>% select(-acquisition)
set.seed(321)
dur_part <- sample(nrow(durdf1),0.8*nrow(durdf1),replace = F)
dur_train1 <- durdf1[dur_part,]
dur_test1 <- durdf1[-dur_part,]
names(dur_train1)
set.seed(321)
rfdur <- rfsrc(duration ~ profit + acq_exp + ret_exp + freq + crossbuy + sow + industry + revenue + employees, #-customer -acq_exp_sq -ret_exp_sq -freq_sq,
data = dur_train1,
importance = TRUE,
ntree = 500)
rfdur
data.frame(importance = rfdur$importance) %>%
tibble::rownames_to_column(var = "variable") %>%
ggplot(aes(x = reorder(variable,importance), y = importance)) +
geom_bar(stat = "identity", fill = "orange", color = "black")+
coord_flip() +
labs(x = "Variables", y = "Variable importance")
#     theme_nice
rfdur$importance
dur_mindepth <- max.subtree(rfdur,
sub.order = TRUE)
print(round(dur_mindepth$order, 3)[,1])
dur_mindepth$sub.order
find.interaction(rfdur,
method = "vimp",
importance = "permute")
# regression with linear specification
dur_reg_lin <- lm(duration ~  .-acq_exp_sq -ret_exp_sq -freq_sq -customer, data = select(dur_train1, -acq_preds))
dur_reg_exp <- lm(duration ~  .-customer, data = select(dur_train1, -acq_preds))
summary(dur_reg_lin)
summary(dur_reg_exp)
min(rfdur$xvar$ret_exp)
max(rfdur$xvar$ret_exp)
ret_exp_seq = seq(0,1100,20)
min(rfdur$xvar$freq)
max(rfdur$xvar$freq)
min(rfdur$xvar$acq_exp)
max(rfdur$xvar$acq_exp)
dur_marginal_effect <- randomForestSRC::partial(rfdur,
partial.xvar = "ret_exp",
partial.values = ret_exp_seq)
dur_means_exp <- dur_marginal_effect$regrOutput$duration %>% colMeans()
dur_me_df <-
data.frame(pred_duration = dur_means_exp, ret_exp_seq = ret_exp_seq)
pacman::p_load(survival, randomForestSRC, MASS, SMCRM, tidyverse, here, skimr, corrplot, rpart)
data(acquisitionRetention)
rawdf <- acquisitionRetention
str(rawdf)
head(rawdf)
skim(rawdf)
rawdf <- rawdf %>% mutate_at(c('industry', 'acquisition'), as.factor)
#column definitions
?acquisitionRetention
rawdf %>% select_if(is.numeric) %>% cor() %>% corrplot(method = 'number', number.cex = 0.6)
# Survival Plot
surv <- data.frame(duration = seq(0,max(rawdf$duration), by = 1))
surv1 <- surv %>%
group_by(duration) %>%
mutate(dist = sum(rawdf$duration > duration))
#greater than removes all of the results where duration == 0, i.e. those not acquired
surv1 %>% ggplot(aes(x = duration, y = dist)) +
geom_line() +
scale_y_continuous(name = 'Count', sec.axis = sec_axis(transform = ~./max(surv1$dist), name = 'Distribution'))
sum(rawdf[which(rawdf$acquisition == 0),]$duration)
rawdf %>% select(ends_with('sq')) %>% names()
set.seed(321)
acq_part <- sample(nrow(rawdf),0.8*nrow(rawdf),replace = F)
acq_train1 <- rawdf[acq_part,]
acq_test1 <- rawdf[-acq_part,]
acq_train1 <- acq_train1 %>% select(-c(profit, duration, ret_exp, ret_exp_sq, freq, freq_sq, crossbuy, sow))
acq_test1 <- acq_test1 %>% select(-c(profit, duration, ret_exp, ret_exp_sq, freq, freq_sq, crossbuy, sow))
set.seed(321)
logfit1 <- step(glm(acquisition ~ . -customer,
data = acq_train1, family = binomial),
direction = "backward", trace = 0)
summary(logfit1)
car::vif(logfit1)
set.seed(321)
logfit2 <- step(glm(acquisition ~ . -acq_exp_sq -customer,
data = acq_train1, family = binomial),
direction = "backward", trace = 0)
summary(logfit2)
car::vif(logfit2)
plot(logfit2)
acq_preds <- data.frame(actual = acq_test1$acquisition,
log_preds = predict(logfit2, acq_test1, type = 'response')) %>% mutate(
log_preds = as.factor(ifelse(log_preds >= 0.5, 1, 0))
)
set.seed(321)
dtfit1 <- rpart(acquisition ~ . -customer, data = acq_train1)
summary(dtfit1)
rattle::fancyRpartPlot(dtfit1, sub = '')
acq_preds$dt_preds <- predict(dtfit1, acq_test1)
set.seed(321)
rffit1 <- rfsrc(acquisition ~ . -acq_exp_sq -customer,
data = acq_train1,
importance = TRUE,
ntree = 100)
rffit1
rffit1$importance
acq_mindepth <- max.subtree(rffit1, sub.order = T)
print(round(acq_mindepth$order, 3)[,1])
find.interaction(rffit1, method = 'vimp', importance = 'permute')
acq_test_prob <- predict(rffit1, newdata = acq_test1)$predicted[,2]
acq_preds$rf_preds <- acq_test_prob
acq_preds <- acq_preds %>% mutate(rf_preds = as.factor(ifelse(rf_preds >= 0.5, 1, 0)))
caret::confusionMatrix(acq_preds$log_preds, reference = acq_preds$actual, positive = '1')
caret::confusionMatrix(acq_preds$rf_preds, reference = acq_preds$actual, positive = '1')
acq_raw_prob <- predict(rffit1, newdata = select(rawdf, names(acq_test1)))$predicted[,2]
durdf <- rawdf %>% bind_cols(preds = acq_raw_prob) %>% mutate(
acq_preds = as.factor(ifelse(preds >= 0.5, 1, 0))
)
caret::confusionMatrix(durdf$acq_preds, durdf$acquisition, positive = '1')
durdf1 <- durdf %>% filter(acq_preds == 1) %>% select(-acquisition)
set.seed(321)
dur_part <- sample(nrow(durdf1),0.8*nrow(durdf1),replace = F)
dur_train1 <- durdf1[dur_part,]
dur_test1 <- durdf1[-dur_part,]
names(dur_train1)
set.seed(321)
rfdur <- rfsrc(duration ~ profit + acq_exp + ret_exp + freq + crossbuy + sow + industry + revenue + employees, #-customer -acq_exp_sq -ret_exp_sq -freq_sq,
data = dur_train1,
importance = TRUE,
ntree = 500)
rfdur
data.frame(importance = rfdur$importance) %>%
tibble::rownames_to_column(var = "variable") %>%
ggplot(aes(x = reorder(variable,importance), y = importance)) +
geom_bar(stat = "identity", fill = "orange", color = "black")+
coord_flip() +
labs(x = "Variables", y = "Variable importance")
#     theme_nice
rfdur$importance
dur_mindepth <- max.subtree(rfdur,
sub.order = TRUE)
print(round(dur_mindepth$order, 3)[,1])
dur_mindepth$sub.order
find.interaction(rfdur,
method = "vimp",
importance = "permute")
# regression with linear specification
dur_reg_lin <- lm(duration ~  .-acq_exp_sq -ret_exp_sq -freq_sq -customer, data = select(dur_train1, -acq_preds))
dur_reg_exp <- lm(duration ~  .-customer, data = select(dur_train1, -acq_preds))
summary(dur_reg_lin)
summary(dur_reg_exp)
min(rfdur$xvar$ret_exp)
max(rfdur$xvar$ret_exp)
ret_exp_seq = seq(0,1100,20)
min(rfdur$xvar$freq)
max(rfdur$xvar$freq)
min(rfdur$xvar$acq_exp)
max(rfdur$xvar$acq_exp)
dur_marginal_effect <- randomForestSRC::partial(rfdur,
partial.xvar = "ret_exp",
partial.values = ret_exp_seq)
dur_means_exp <- dur_marginal_effect$regrOutput$duration %>% colMeans()
dur_me_df <-
data.frame(pred_duration = dur_means_exp, ret_exp_seq = ret_exp_seq)
dur_me_df <-
data.frame(pred_duration = dur_means_exp, ret_exp_seq = ret_exp_seq)
ggplot(dur_me_df, aes(x = ret_exp_seq, y = pred_duration)) +
geom_point(shape = 21, color = "purple", size = 2, stroke = 1.2)+
geom_smooth(method = "lm", formula = y ~ poly(x,3), se = FALSE, color = "black")+ # try with other values
labs(x = "Retention Expenditures in $", y = "Predicted duration") +
scale_x_continuous(breaks = seq(230,2000,120))
pacman::p_load(survival, randomForestSRC, MASS, SMCRM, tidyverse, here, skimr, corrplot, rpart, e1071)
set.seed(321)
svmfit1 <- svm(acquisition ~ . -customer,
data = acq_train1,
type = "C-classification",
kernel = "radial", # Radial kernel is common for nonlinear problems
cost = 1, # Default cost; tune this later
scale = TRUE) # Ensure variables are scaled
# Summary of the model
summary(svmfit1)
# Predict on the test data
svm_preds <- predict(svmfit1, acq_test1)
# Add SVM predictions to the predictions dataframe
acq_preds$svm_preds <- svm_preds
# Evaluate the SVM model performance
svm_cm <- caret::confusionMatrix(acq_preds$svm_preds,
reference = acq_preds$actual,
positive = '1')
# Display the confusion matrix
print(svm_cm)
set.seed(321)
svmfit1 <- svm(acquisition ~ . -customer,
data = acq_train1,
type = "C-classification",
kernel = "radial", # Radial kernel is common for nonlinear problems
cost = 1, # Default cost; tune this later
scale = TRUE) # Ensure variables are scaled
# Summary of the model
summary(svmfit1)
set.seed(321)
svmfit1 <- svm(acquisition ~ . -customer,
data = acq_train1,
type = "C-classification",
kernel = "radial",
cost = 1,
scale = TRUE)
summary(svmfit1)
svm_preds <- predict(svmfit1, acq_test1)
svm_preds <- predict(svmfit1, acq_test1)
# Add SVM predictions to the predictions dataframe
acq_preds$svm_preds <- svm_preds
svm_cm <- caret::confusionMatrix(acq_preds$svm_preds,
reference = acq_preds$actual,
positive = '1')
# Display the confusion matrix
print(svm_cm)
svm_cm <- caret::confusionMatrix(acq_preds$svm_preds,
reference = acq_preds$actual,
positive = '1')
print(svm_cm)
svmfit_weighted <- svm(
acquisition ~ . -customer,
data = acq_train1,
type = "C-classification",
kernel = "radial",
cost = 1,
class.weights = c('0' = 1, '1' = 2) # Adjust weights as needed
)
rm(svmfit_weighted)
pacman::p_load(survival, randomForestSRC, MASS, SMCRM, tidyverse, here, skimr, corrplot, rpart, e1071)
data(acquisitionRetention)
rawdf <- acquisitionRetention
str(rawdf)
head(rawdf)
skim(rawdf)
rawdf <- rawdf %>% mutate_at(c('industry', 'acquisition'), as.factor)
#column definitions
?acquisitionRetention
rawdf %>% select_if(is.numeric) %>% cor() %>% corrplot(method = 'number', number.cex = 0.6)
# Survival Plot
surv <- data.frame(duration = seq(0,max(rawdf$duration), by = 1))
surv1 <- surv %>%
group_by(duration) %>%
mutate(dist = sum(rawdf$duration > duration))
#greater than removes all of the results where duration == 0, i.e. those not acquired
surv1 %>% ggplot(aes(x = duration, y = dist)) +
geom_line() +
scale_y_continuous(name = 'Count', sec.axis = sec_axis(transform = ~./max(surv1$dist), name = 'Distribution'))
sum(rawdf[which(rawdf$acquisition == 0),]$duration)
rawdf %>% select(ends_with('sq')) %>% names()
set.seed(321)
acq_part <- sample(nrow(rawdf),0.8*nrow(rawdf),replace = F)
acq_train1 <- rawdf[acq_part,]
acq_test1 <- rawdf[-acq_part,]
acq_train1 <- acq_train1 %>% select(-c(profit, duration, ret_exp, ret_exp_sq, freq, freq_sq, crossbuy, sow))
acq_test1 <- acq_test1 %>% select(-c(profit, duration, ret_exp, ret_exp_sq, freq, freq_sq, crossbuy, sow))
set.seed(321)
logfit1 <- step(glm(acquisition ~ . -customer,
data = acq_train1, family = binomial),
direction = "backward", trace = 0)
summary(logfit1)
car::vif(logfit1)
set.seed(321)
logfit2 <- step(glm(acquisition ~ . -acq_exp_sq -customer,
data = acq_train1, family = binomial),
direction = "backward", trace = 0)
summary(logfit2)
car::vif(logfit2)
plot(logfit2)
acq_preds <- data.frame(actual = acq_test1$acquisition,
log_preds = predict(logfit2, acq_test1, type = 'response')) %>% mutate(
log_preds = as.factor(ifelse(log_preds >= 0.5, 1, 0))
)
set.seed(321)
svmfit1 <- svm(acquisition ~ . -customer,
data = acq_train1,
type = "C-classification",
kernel = "radial",
cost = 1, #<--we can adjust this if needed
scale = TRUE)
summary(svmfit1)
svm_preds <- predict(svmfit1, acq_test1)
acq_preds$svm_preds <- svm_preds
svm_cm <- caret::confusionMatrix(acq_preds$svm_preds,
reference = acq_preds$actual,
positive = '1')
print(svm_cm)
set.seed(321)
dtfit1 <- rpart(acquisition ~ . -customer, data = acq_train1)
summary(dtfit1)
rattle::fancyRpartPlot(dtfit1, sub = '')
acq_preds$dt_preds <- predict(dtfit1, acq_test1)
set.seed(321)
rffit1 <- rfsrc(acquisition ~ . -acq_exp_sq -customer,
data = acq_train1,
importance = TRUE,
ntree = 100)
rffit1
rffit1$importance
acq_mindepth <- max.subtree(rffit1, sub.order = T)
print(round(acq_mindepth$order, 3)[,1])
find.interaction(rffit1, method = 'vimp', importance = 'permute')
acq_test_prob <- predict(rffit1, newdata = acq_test1)$predicted[,2]
acq_preds$rf_preds <- acq_test_prob
acq_preds <- acq_preds %>% mutate(rf_preds = as.factor(ifelse(rf_preds >= 0.5, 1, 0)))
caret::confusionMatrix(acq_preds$log_preds, reference = acq_preds$actual, positive = '1')
caret::confusionMatrix(acq_preds$rf_preds, reference = acq_preds$actual, positive = '1')
acq_raw_prob <- predict(rffit1, newdata = select(rawdf, names(acq_test1)))$predicted[,2]
durdf <- rawdf %>% bind_cols(preds = acq_raw_prob) %>% mutate(
acq_preds = as.factor(ifelse(preds >= 0.5, 1, 0))
)
caret::confusionMatrix(durdf$acq_preds, durdf$acquisition, positive = '1')
durdf1 <- durdf %>% filter(acq_preds == 1) %>% select(-acquisition)
set.seed(321)
dur_part <- sample(nrow(durdf1),0.8*nrow(durdf1),replace = F)
dur_train1 <- durdf1[dur_part,]
dur_test1 <- durdf1[-dur_part,]
names(dur_train1)
set.seed(321)
rfdur <- rfsrc(duration ~ profit + acq_exp + ret_exp + freq + crossbuy + sow + industry + revenue + employees, #-customer -acq_exp_sq -ret_exp_sq -freq_sq,
data = dur_train1,
importance = TRUE,
ntree = 500)
rfdur
data.frame(importance = rfdur$importance) %>%
tibble::rownames_to_column(var = "variable") %>%
ggplot(aes(x = reorder(variable,importance), y = importance)) +
geom_bar(stat = "identity", fill = "orange", color = "black")+
coord_flip() +
labs(x = "Variables", y = "Variable importance")
#     theme_nice
rfdur$importance
dur_mindepth <- max.subtree(rfdur,
sub.order = TRUE)
print(round(dur_mindepth$order, 3)[,1])
dur_mindepth$sub.order
find.interaction(rfdur,
method = "vimp",
importance = "permute")
# regression with linear specification
dur_reg_lin <- lm(duration ~  .-acq_exp_sq -ret_exp_sq -freq_sq -customer, data = select(dur_train1, -acq_preds))
dur_reg_exp <- lm(duration ~  .-customer, data = select(dur_train1, -acq_preds))
summary(dur_reg_lin)
summary(dur_reg_exp)
min(rfdur$xvar$ret_exp)
max(rfdur$xvar$ret_exp)
ret_exp_seq = seq(0,1100,20)
min(rfdur$xvar$freq)
max(rfdur$xvar$freq)
min(rfdur$xvar$acq_exp)
max(rfdur$xvar$acq_exp)
dur_marginal_effect <- randomForestSRC::partial(rfdur,
partial.xvar = "ret_exp",
partial.values = ret_exp_seq)
dur_means_exp <- dur_marginal_effect$regrOutput$duration %>% colMeans()
dur_me_df <-
data.frame(pred_duration = dur_means_exp, ret_exp_seq = ret_exp_seq)
caret::confusionMatrix(acq_preds$svm_preds, reference = acq_preds$actual, positive = '1')
